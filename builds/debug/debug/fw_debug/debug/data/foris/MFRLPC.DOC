









                Frame Representation Language

                      СИСТЕМА  MFRL/PC

                        (Версия 3.0)







       Инструкции по эксплуатации и описание языка FRL







                    Группа системного программирования

                             Руководитель: Семенова Е.Т.
                             Разработчики: Байдун В.В.
                                           Бунин А.И.







                           23.10.88
.
                            - 2 -


     Инструментальная система MFRL/PC  (Версия: 3.0, 1987, 1988)


     НАЗНАЧЕНИЕ
        Система для представления знаний о предметных областях в ЭВМ
     ТИП ЭВМ
        Персональные компьютеры ЕС-1840/41, IBM PC XT/AT и их аналоги
     ИНСТРУМЕНТАЛЬНАЯ СРЕДА
        Система MULTIWIND (muLISP-like)
     ВОЗМОЖНОСТИ СИСТЕМЫ
        - представление знаний в виде сети фреймов с  присоединен-
          ными процедурами;
        - управляемое наследование фреймов и процедур;
        - встроенный механизм сопоставления сетей фреймов;
        - средства для задания продукционных правил во фреймах;
     ОСНОВНЫЕ ЭКСПЛУАТАЦИОННЫЕ ПОКАЗАТЕЛИ
        Автоматизирована:
        - работа с расширенной памятью (extended memory)
        - настройка и работа с монохромной и цветографической пла-
          тами адаптера монитора;
        - загрузка с внешних носителей фреймов и процедур, не най-
          денных в оперативной памяти;
        Допускаются возможности:
        - выделения из MFRL/PC в отдельный файл произвольного под-
          множества функций (в том числе и созданных диалогов) для
          их дальнейшего независимого использования;
        - подключения внешних информационных наборов с ассоциатив-
          ным способом записи и считывания объектов по их именам;
        - перепрограммирования клавиатуры;
        - запуска любой внешней программы без выхода из MFRL/PC (в
          том числе и файлового редактора);
        - загрузка русского шрифта при работе с монитором и выводе
          на печать;
.
                            - 3 -


     Версия 3.0 по сравнению с 1.0 имеет следующие дополнения:
     - возможность настройки MFRL/PC на конкретное внешнее
программное обеспечение и аппаратуру (файл *.SET)
     - возможность автозагрузки содержимого файла INIT.LSP при
загрузке MFRL/PC
     - возможность подключения любого внешнего файлового ре-
дактора и вызов его без выхода из MFRL/PC
     - возможность загрузки русского шрифта и работы с ним в
графическом режиме монитора
     - возможность перепрограммирования принтера для печати
текстов с русским шрифтом
     - возможность использования и создания библиотечных фай-
лов.
     - возможность сопоставления фреймов и дескрипторов;
     - возможность записи продукционных правил во фреймах.






.
                            - 4 -
                          СОДЕРЖАНИЕ
ВВЕДЕНИЕ                                                    5
1. Запуск системы MFRL/PC                                   6
2. Общая характеристика языка FRL                           6
2.1. Фреймы                                                 6
2.2. Сети на фреймах                                        7
2.3. Типы данных.                                           7
2.4. Наследование данных.                                   9
2.5. Активация присоединенных процедур.                    10
2.6. Типы комментариев.                                    13
2.7. Модификация сети фреймов.                             13
2.8. Извлечение данных из сети фреймов.                    14
2.9. Мэтчинг на сети фреймов.                              16
2.9.1. Дескрипторы.                                        17
2.9.2. Определение мэтчинга.                               18
2.9.3. Результат сопоставления.                            19
2.10. Трассировка                                          19
2.11. Интерфейс с внешними запоминающими устройствами      21
2.11.1. Взаимодействие с виртуальной базой объектов        21
2.11.2.  Создание и использование библиотечных файлов      22
П1.1. Основные обозначения                                 24
П1.1.1 Обозначения для системных функций                   24
П1.1.2 Обозначения для FRL  функций                        24
П1.2.2.  Переменные и стеки MFRL/PC                        26
П1.3. Изменение сети фреймов и процедур.                   28
П1.4. Извлечение информации из сети фреймов.               32
П1.5. Предикаты MFRL/PC.                                   35
П1.6. Интерфейс с виртуальной базой объектов (ВБО).        37
П1.7. Активация процедур                                   39
П1.8. Вспомогательные функции.                             41

.
                            - 5 -


                          ВВЕДЕНИЕ
     В  настоящем  руководстве  описывается   версия   системы
MFRL/PC  (Frame  Representation Language with Matching), пред-
назначенной для представления знаний о предметных  областях  в
ЭВМ.
     Язык MFRL/PC  разработан  на  базе   языка   FRL   (Frame
Representation Language, Roberts & Goldstein, 1977) разработан
группой системного программирования под руководством Семеновой
Е.Т.
     Настоящая версия реализована в рамках системы MULTIWIND
для персональных ЭВМ ЕС-1840\41, IBM PC XT\AT.
     Авторы предлагаемой реализации пользуются случаем для вы-
ражения благодарности Семеновой Е.Т., Селегею В.П., Пелковско-
му В.Ю., Комаровой Э.С., Пашинцеву В.Д. за их замечания и  по-
желания, возникшие в ходе эксплуатации системы и написании до-
кументации по ней.


.
                            - 6 -


                  1. Запуск системы MFRL/PC


     Для загрузки системы необходимо ввести с клавиатуры:

                        MFRLPC

     затем нажать  "Enter".  Об успешной загрузке системы будет
сигнализировать появление  строки  с  описанием  функциональной
клавиатуры в нижней части экрана, а в левом верхнем углу экрана
будет напечатано "E}" и там же будет находится курсор.
    Для удобства пользователя система MFRLPC совмещена с систе-
мой muSHELL,  включающей ряд  сервисных  функций,  связанных  с
функциональной клавиатурой и возможность работы со строчным ре-
дактором.

                          Замечания

     1) Для прерывания процесса вычисления следует нажать кла-
вишу Esc.
     2)  Для  избежания  коллизии имен переменных настоятельно
рекомендуем использовать уникальные имена глобальных  перемен-
ных. Например все имена глобальных переменных могли бы, напри-
мер, начинаться с префикса "#"
     Все глобальные переменные  выделены символом "*"


              2. Общая характеристика языка FRL

     Язык  FRL  предназначен  для обработки фреймов - структур
данных специального вида, которые могут быть использованы  как
для декларативного,  так и для процедурного представления зна-
ний.  В основе этого языка лежит понятие фрейма,  которое было
предложено М.Минским.  Заметим,  что FRL не является самостоя-
тельным языком программирования,  а суть расширение некоторого
языка обработки сложноструктурированных данных,  как правило -
LISPа, что и подразумевается в дальнейшем изложении. Описывае-
мый в данном документе язык соответствует версии  3.0  системы
MFRL/PC, полное руководство по которой содержится в Приложени-
ях 1 и 2.

                         2.1. Фреймы

     Синтаксически фрейм можно представлять себе как  поимено-
ванную  ассоциативную  списковую структуру (ПАСС), первый эле-
мент которой является именем фрейма, а остальные - его  слота-
ми.  Имя фрейма должно быть атомом (в смысле языка LISP). Каж-
дый фрейм имеет уникальное имя в системе.
     Слот в свою очередь является ПАСС, первый элемент которой
-  имя  слота . Остальные компоненты называются аспектами. Имя
слота должно быть атомом. Каждый  слот  имеет  уникальное  имя
внутри фрейма. Порядок слотов внутри фрейма несущественен.
     Аспект  также  является  ПАСС.  Именем аспекта служит его
первый элемент. Остальные элементы называются данными. Имя ас-
пекта  (атом) уникально внутри слота. Порядок аспектов в слоте
несущественен.
     Данное - это ПАСС, первый элемент которой есть имя данно-
го  или  его  значение . Остальные элементы данного называются
комментариями. Данным может быть любой объект в  смысле  языка
LISP  (в  том  числе  имя  функции или вызов функции), а также

                            - 7 -
фрейм или имя фрейма. Каждое значение уникально внутри  аспек-
та. Порядок данных в аспекте несущественен.
     Комментарий  является  поименованным  множеством,  первый
элемент которого называется меткой, а остальные - сообщениями.
Метка  должна быть атомом. Каждый комментарий имеет уникальную
метку внутри данного. Порядок комментариев в данном неважен.
     Сообщением  может  быть  любой  объект  LISPа.  Сообщения
вставляются  в  комментарий как в стек, а удаляются из него по
первому вхождению.
     Синтаксис фрейма в расширенной нотации Бэкуса-Наура  (ме-
тасимволы: "::=" "<" ">" "|" "{" "}" "[" "]" ):

     <фрейм> ::= ( <имя фрейма> { <слот> } )
     <имя фрейма> ::= <атом>
     <слот> ::= ( <имя слота> { <аспект> } )
     <имя слота> ::= <отношение> | <свойство> | SELF
     <отношение> ::= <атом>
     <свойство> ::= <атом>
     <аспект> ::= ( <имя аспекта> { <данное> } )
     <имя аспекта> ::= <атом>
     <данное> ::= ( <имя данного> { <комментарий> } )
                   | <функтор>

     <функтор> ::= OR | ALT | NOT | IF | ТHЕN | ELSE | FI
     <имя данного> ::= <значение>
     <значение> ::= <атом> | <d-пара> |
                    <имя LISP- или FRL-функции> |
                    <вызов LISP- или FRL-функции> |
                    <имя фрейма> | <фрейм>
     <комментарий> ::= ( <имя комментария> { <сообщение> } )
     <имя комментария> ::= <метка>
     <метка> ::= <атом>
     <сообщение> ::= <s-выражение>


                    2.2. Сети на фреймах

     Сети на фреймах могут создаваться посредством использова-
ния имен фреймов в качестве значений слотов. Простейшая связь
с именем R от фрейма F1 к фрейму F2 выглядит так:

     Фрейм F1: (F1 ... (R ($VALUE (F2) ) ) ...)

     В FRL существуют два специальных типа связей между фрей-
мами:
     - АКО-связь (от английского "А Kind of" - "один из");
     - INSTANCE-связь (обратная по отношению к АКО).
     Эти связи служат для создания АКО/INSTANCE-иерархий.
Пусть фрейм F1 связан АКО-связью с фреймом F2. В этом случае
фрейм F2 является прототипом для фрейма F1, а фрейм F1 - эк-
земпляром для F2. Каждый фрейм может иметь несколько прототи-
пов и экземпляров.
     Если фрейм F1 соединен АКО-связью. с фреймом F2, то все
значения фрейма F2 могут наследоваться фреймом F1. Это означа-
ет, что каждый запрос на значения некоторого слота во фрейм F1
может быть дополнен запросом на значения этого же слота, но во
фрейм F2 и т.д. Подробнее о наследовании смотри в п.2.4.


                      2.3. Типы данных.

     В FRL существуют три типа значений (данных):

                            - 8 -
     - прямое значение;
     - косвенное значение;
     - вычислимое значение.
     Косвенное данное имеет комментарий (STATUS: INDIRECT) и
может также содержать комментарии с метками SLOT: и FACET:.
Запрос на косвенное данное с именем V из аспекта А слота S
фрейма F будет переадресован во фрейм V слот S аспект А. При
этом сообщения из комментариев с метками SLOT: и FACET: (если
они заданы) заменяют S и А соответственно. Если именем косвен-
ного данного является *, то она обозначает имя текущего фрей-
ма.

     Пример. Пусть имеются фреймы F1 и F2:

 F1: (F1 ... (S ... (А (F2 (STATUS: INDIRECT) (SLOT: Q) ) )
                                ... ) ... )
 F2: (F2 ... (S ... (А (V1) )
             (Q ... (А (V2) ) ...)
     Тогда в ответ на запрос на данное из аспекта А слота S
фрейма F1 будет выдано значение V2, т.к. значение F2 является
косвенным.
     Вычислимое данное - это такое данное, которое
     - либо  содержится  в  аспектах  $IF-ADDED,  $IF-REMOVED,
$IF-NEEDED,   $IF-INSTANTIATED,  $REQUIRE,  $IF-GET,  $IF-PUT,
$IF-REM и не имеет комментария (STATUS: NOEVAL),
     - либо содержится в аспектах  $VALUE,  $DEFAULT  и  имеет
комментарий (STATUS: ЕVАL).
     Любое  вычислимое  данное может иметь также комментарии с
метками PARM: или PARMQ:.
     Если именем вычислимого данного является атом P, то отве-
том на запрос на это данное является результат вызова процеду-
ры P с актуальными аргументами из аспектов с метками PARM: или
PARMQ:  (в последнем случае аргументы не вычисляются). Если же
именем вычислимого данного является неатомарная LISP-форма, то
ответом  на запрос на значение такого данного является резуль-
тат вычисления этой формы.
     Обращение к присоединенной процедуре имеет следующий син-
таксис:

          ( <имя процедуры>
               (PARM:  <S-выражение1> <S-выражение2> ... )
               (PARMQ: <S-выражение1> <S-выражение2> ... )
              [(STATUS: EVAL )] )
либо
          ( <неатомарная LISP-форма> [(STATUS: EVAL)]).

     В первом случае процедура с указанным именем  применяется
к  списку  аргументов, формируемому на основании комментариев,
тогда как во втором случае обычным способом  вычисляется  лис-
повская форма.

     Примечание: здесь и далее при  определении  синтаксиса  в
квадратные  скобки берутся необязательные элементы, в фигурные
- альтернативные элементы, а в угловые скобки заключаются  не-
терминальные символы.

     Пример. Пусть имеется фрейм F

        F: (F ... (S ... ($VALUE (LIST (STATUS: ЕVАL)
                                       (PARMQ: А B C) ))
                        ... ) ... )


                            - 9 -
     Тогда в ответ на запрос данных из аспекта $VALUE слота S
фрейма F будет выдано не данное с именем LIST, а данное с име-
нем (А B C), т.е. с именем, полученным в результате вычисления
функции LIST с аргументами А, B и C. То же самое получится и в
случае, когда фрейм F имеет вид

 F: (F ... (S ... ($VALUE ((LIST 'А 'B 'C) (STATUS: ЕVАL)))
                            ... ) ... )

     Все остальные данные являются прямыми. Они извлекаются из
сети фреймов без какой-либо дополнительной обработки.
     Каждый запрос на данные во фрейм F слот S аспект А выпол-
няется в специальной FRL-среде, в которой:
     - системная переменная :FRAME связана с F;
     - системная переменная :SLOT  связана с S;
     - системная переменная :FАCЕТ связана с А.


                  2.4. Наследование данных.

     Термин  "наследование  данных" ( = "наследование значений
свойств", = "наследование свойств") в смысле FRL означает "за-
мену запроса к некоторому фрейму за желаемыми данными запросом
к (может быть) другому фрейму за (может быть)  другими  данны-
ми". В этом определении отражена важная особенность наследова-
ния свойств в FRL: наследование свойств является сугубо  дина-
мическим  понятием и проявляется только в момент поиска ответа
на запрос.
     В FRL есть три типа наследования  свойств,  хранящихся  в


аспекте $VALUE:
     - АКО-наследование;
     - локальное наследование;
     - DEFAULT-наследование.
     Для  свойств из других аспектов валидно только АКО-насле-
дование.
     Термин "АКО-наследование" означает "замену запроса к  не-
которому  фрейму  за данными запросом к его прототипу за этими
данными".
     Термин "локальное наследование" означает "замену  запроса
к  некоторому фрейму за данными запросом к его локальному про-
тотипу за этими данными". Фрейм F1 называется локальным прото-
типом  для  фрейма  F2 относительно слота S, если он находится
среди значений во фрейме F2 слоте S аспекте $АКО:
       (F2 ... (S ... ($АКО ... (F1) ... ) ... ) ... )
     Локальное наследование более приоритетно, чем глобальное.
     Термин "DEFAULT-наследование" означает "замену запроса  к
некоторому  фрейму  за  данными  запросом к этому же фрейму за
этими же данными, но из аспекта $DEFAULT".
     Пример АКО-наследования. Пусть даны фреймы F1 и F2:

      F1: (F1 ... (S ... ($VALUE (V1) (V2)) ... ) ... )
      F2: (F2 ... (АКО ($VALUE (F1))) ... )

     Тогда в ответ на запрос к фрейму F2 за значениями слота S
будут выданы значения V1 и V2.
     Заметим, что АКО-иерархия (как глобальная так и локаль-
ная) может быть имплицитной, т.е. строиться динамически в про-
цессе поиска. Для этого данное в слоте АКО фрейма-экземпляра
(в примере это F2) должно быть вычислимым или косвенным.


                            - 10 -


           2.5. Активация присоединенных процедур.

     В FRL существуют два способа активации присоединенных
процедур:
     - явный вызов;
     - вызов по ситуации.
     При явном вызове указываются имена фрейма, слота и аспек-
та  (как  правило, это $IF-NEEDED), в которых содержится вызов
требуемой процедуры. Функции MFRL/PC, управляющие явным  вызо-
вом присоединенных процедур, приведены в Приложении 1, п. 1.7.
     При ситуативном вызове указывается условие, при  выполне-
нии  которого  автоматически вызывается требуемая процедура. В
FRL  имеются  следующие   стандартные   ситуации:   $IF-ADDED,
$IF-REMOVED,  $IF-INSTANTIATED,  $IF-GETED,  $IF-ADD, $IF-PUT,
$IF-REM, $IF-GET. Во всех этих случаях присоединенные процеду-
ры  хранятся под одноименными аспектами и могут наследоваться.
Если к одному аспекту присоединено несколько процедур, возмож-
но разделенных функторами, то они вычисляются согласно следую-
щим правилам:
     - в отсутствии функторов происходит последовательный  вы-
зов  процедур  посредством FАPPLY, причем результатом является
конъюнкция результатов отдельных процедур. Это  означает,  что
первая  встреченная процедура со значением NIL прекращает про-
цесс.
     - функторами ALT разделяются альтернативы. Если  вычисле-
ние первой альтернативы дает значение NIL, то вычисляется сле-
дующая и т.д.
     - функторами OR разделяются альтернативы внутри отдельно-
го конъюнкта.
     -  функтор  NOT  означает,  что значение следующей за ним
процедуры следует поменять на противоположное, т.е. не NIL  на
NIL, а NIL - на Т.
     -  функтор IF означает начало условной конструкции, имею-
щей традиционный вид:
    <усл. констр.> ::= IF <последовательность конъюнктов>
                     THEN <последовательность конъюнктов>
                     [ELSE <последовательность конъюнктов>] FI
причем <последовательность  конъюнктов>  может  содержать  все
функторы, кроме ALT.
     При вычислении присоединенных процедур актуальна FRL-сре-
да, описанная в п.2.3. Кроме этого, переменная :VALUE принима-
ет в качестве значения то данное, которое вызывает ее  активи-
зацию.
     Процедуры  из  аспекта $IF-ADDED вызываются в том случае,
если в содержащий их слот добавляется новое данное.

     Пример. Пусть имеются фреймы F1 и F2:

 F1:  (F1  ...  (S  ($IF-ADDED  ((PUSH  (LIST  :FRAME :SLOT
            :VАLUED) *ADDED*)))) ... )
 F2: (F2 ... (АКО ($VALUE (F1))) ... )

     Тогда при занесении значения 5 в слот S фрейма F2  срабо-
тает процедура PUSH, которая занесет в стек *ADDED* список (F2
S 5).
     Процедуры из аспекта $IF-REMOVED вызываются при  удалении
данного из содержащего их слота.
     Пример. Пусть имеются фреймы F1 и F2:

 F1: (F1 ... (S ($IF-REMOVED ((PUSH :VALUE *REMOVED*))))

                            - 11 -
             ... )
 F2: (F2 ... (АКО ($VALUE (F1)))
             (S ($VALUE (5))) ... )

     Тогда при удалении значения 5 из слота S фрейма F2 срабо-
тает процедура PUSH, которая занесет 5 в стек *REMOVED*.
     Процедуры из аспекта $IF-INSTANTIATED выполняются в  слу-
чае  создания экземпляра некоторого фрейма (см. описание функ-
ции FINSTANTIATE в Приложении 1, п.1.3).
    Процедуры  из  аспекта  $IF-GETED  вызываются при удалении
данного из содержащего их слота.
    Аспекты $IF-GET,  $IF-ADD,  $IF-REM (Рис.  1.) в  настоящей
версии предусмотрены только в функциях: FGET-, FGET1-, FGETN- и
содержат процедуры конвертирования данных,  назначение  которых
заключается в следующем:  над каждым из данных FRL, участвующих
в операциях создания,  удаления,  поиска, выполняются процедуры
из  аспектов $IF-ADD (при добавлении данного во фрейм), $IF-REM
(при удалении данного из фрейма),  $IF-GET (при извлечении дан-
ного  из  фрейма).  При этом данное FRL заменяется на результат
выполнения этой процедуры. Если результат NIL, то над этим дан-
ным никаких операций не производится.
    Аспекты  конвертирования предоставляют пользователю мощные
средства, позволяющие с каждым данным связывать  соответствую-
щую обрабатывающую процедуру. Эта возможность представляет ин-
терес  при расширении стандартных возможностей FRL (расширение
механизмов наследования, комментариев и  т.п.).  Например,  во
фрейме F слоте S имена данных являются числами и атомами.

    (F
       (S ($VALUE (5) (A) (6) (B)))
    )

    (FGET 'F 'S) => (5 A 6 B)

    Для  того чтобы функция FGET из слота S фрейма F извлекала
только числа, фрейм F следует модифицировать  следующим  обра-
зом:
    (F
       (S ($VALUE (5) (A) (6) (B))
          ($IF-GET ((AND (NUMBERP :VALUE) :VALUE))))
       )
    )

    После модификации:
.
                            - 12 -

 2╒══════════════════════════════════════════════════════╕
 2│ Функция FRL: поиск, добавление, удаление во фрейме F │
 2╘══════════════════════════╤═══════════════════════════╛
                            2│     единичное данное FRL
           2┌───────>────────┼────────>────────┐
           2│извлечение      │ добавление      │ удаление
           2│                v                 │
           2│Di'             │   Di            │   Di
     2┌─────┴──────┐   ┌─────┴──────┐    ┌─────┴──────┐
     2│процедуры из│   │процедуры из│    │процедуры из│
     2│   $IF-GET  ╞<╗ │   $IF-PUT  ╞<╗  │   $IF-REM  ╞<╗
     2│   P'(Di)   │ ║ │   P''(Di)  │ ║  │    P'''(Di)│ ║
     2└─────┬──────┘ ║ └─────┬──────┘ ║  └─────┬──────┘ ║
           2│Di      ║       │Di''    ║        │Di'''   ║
           2^        ║       v        ║        v        ║
           2└────────╫───────┼────────╫────────┘        ║
 2╔══════════════════╩═══════╧════════╩═════════════════╩╗
 2║                  Фрейм структура F                   ║
 2╚══════════════════════════════════════════════════════╝

            2Рис. 1. Семантика конвертирующих аспектов

.
                            - 13 -

    (FGET 'F 'S) => (5 6)

     Процедуры из аспекта $IF-INSTANTIATED выполняются в  слу-
чае  создания экземпляра некоторого фрейма (см. описание функ-
ции FINSTANTIATE в Приложении 1.1.1).

                   2.6. Типы комментариев.

     В FRL имеются несколько типов комментариев:
     - комментарий с меткой STATUS: используется для индикации
метода  обработки данного при его извлечении. Возможными сооб-
щениями для этого комментария являются ЕVАL, NOEVAL и INDIRECT
(см. п.2.3);
     -  комментарии  с метками SLOT: и FACET: используются для
указания референта косвенного данного. Они  используются  сов-
местно с комментарием (STATUS: INDIRECT) (см. п.2.3);
     -  комментарии  с метками PARM: и PARMQ: используются при
задании аргументов для присоединенных процедур (см. п.2.3);
     - комментарий с меткой FINHERIT: используется для локаль-
ного  управления  наследованием. Если сообщение есть CONTINUE,
то содержащий его слот наследует данные из своих  АКО-прототи-
пов  даже в случае, если он сам и содержит искомые данные. Со-
общение STOP запрещает наследование данных, искомых в содержа-
щем его слоте;
     -  комментарий (TYPE: <тип>) обеспечивает возможность из-
бирательного вызова процедур функциями FPROC, FNEED и FEXEC;
     -  комментарий с меткой IN: вставляется системой в данные
при их извлечении для идентификации фрейма, слота  и  аспекта,
из которых они были извлечены.


               2.7. Модификация сети фреймов.

     Для  модификации сети фреймов используются функции созда-
ния и удаления фрагментов сети фреймов. Описания этих  функций
приведены  в  Приложении  1 в п.1.3. Основными функциями этого
класса являются FPUT, FRЕМОVЕ и FINSTANTIATE.
     Функция
 (FPUT  <имя  фрейма>  <имя слота> <имя аспекта> <значение>
                        [<метка> [<сообщение>]] )

     заносит значение (с меткой и сообщением, если они заданы)
по  указанному  пути, создавая при необходимости отсутствующие
компоненты (фрейм, слот, аспект). При этом наследуются  и  за-
пускаются  процедуры, присоединенные к аспекту $IF-ADDED соот-
ветствующего слота этого фрейма или его прототипов.
     Функция
 (FRЕМОVЕ <имя фрейма> [<имя слота> [<имя аспекта> [<значе-
                          ние> [<метка> [<сообщение>]] ]]] )
     удаляет из фрейма подструктуру, указанную соответствующим
путем. При этом, если удаляется значение, то наследуются и за-
пускаются процедуры, присоединенные к аспекту $IF-REMOVED  со-
держащего слота или наследуемые по АКО-иерархии.
     Функция
 (FINSTANTIATE <имя прототипа> [<имя экземпляра>]  [<слот>] )
     создает  экземпляр  фрейма-прототипа и заполняет этот эк-
земпляр указанными слотами. При этом наследуются и выполняются
процедуры, присоединенные к аспектам $IF-INSTANTIATED всех сло-
тов фрейма-прототипа и полученные результаты заносятся  в  ас-
пекты $DEFAULT соответствующих слотов фрейма-экземпляра.

                            - 14 -
     При  создании  баз фреймов часто приходится создавать ре-
версивные связи. Для автоматизации этого процесса в  FRL  пре-
дусмотрены  функции  FRЕVАDD,  FRЕVRЕМ, FORWADD и FORWREM (см.
Приложение 1, п.1.3).
     Например, процедура  FRЕVАDD,  присоединенная  к  аспекту
$IF-ADDED  слота S фрейма F, создает реверсивные связи во всех
его фреймах-экземплярах при занесении в них прямых связей:
     - Состояние базы фреймов до установления  между  фреймами
F1 и F2 связи S:
      F: (F  ... (S   ($IF-ADDED ((FRЕVАDD 'SREV)))) ... )
     F1: (F1 ... (АКО ($VALUE    (F) ) ) ... )
     F2: (F2 ... (АКО ($VALUE    (F) ) ) ... )
     - Состояние базы фреймов после установления связи S между
фреймами F1 и F2:
      F: без изменений
     F1: (F1 ... (АКО  ($VALUE (F) ) )
                 (S    ($VALUE (F2) ) ) ... )
     F2: (F2 ... (АКО  ($VALUE (F) ) )
                 (SRЕV ($VALUE  (F1) ) ) ... )


           2.8. Извлечение данных из сети фреймов.

     Для извлечения данных из сети фреймов в  MFRL/PC  имеется
набор специальных функций (см. Приложение 1, п. 1.4), основной
из которых является функция FGET.
     В языке FRL имеются средства контроля как стратегии поис-
ка  данных,  так  и желаемого вида ответа на поисковый запрос.


Для этой цели имеются специальные управляющие  ключи,  которые
используются в функциях извлечения информации.
     Функция
(FGET <имя фрейма> <имя слота> [ <имя аспекта> [ <ключи> ]] )
извлекает  данные  из указанного аспекта указанного слота ука-
занного фрейма. Если аспект не задан, то по умолчанию он равен
$VALUE. Форма результата и стратегия поиска задаются при помо-
щи ключей. Операнд ключи представляет собой список, элементами
которого  могут быть: Е, C, -!, -@, -*, О, -H, 0, 2. Эти ключи
имеют следующий смысл:
      Е - результат представляет собой первое извлеченное дан-
ное;
      C - данные в результате будут иметь комментарии;
     -! - вычислимые данные  не будут  вычисляться (т.е. будут
обрабатываться как прямые);
     -@ - косвенные данные обрабатываются как прямые;
     -* - запрещает обработку * как имени текущего фрейма  при
использовании в косвенном данном;
      О - данные наследуются из первого встреченного релевант-
ного фрейма на каждом АКО-пути;
     -H - запрещает АКО-наследование;
      0 (ноль) - запрещает DEFAULT-наследование;
      2 - запрещает DEFAULT-наследование, но в случае неуспеш-
ного поиска данных в аспекте $VALUE повторяет тот  же  запрос,
но в аспект $DEFAULT.
     По-умолчанию действуют следующие ключи:
     L  -  результат выглядит как список всех извлеченных дан-
ных;
     -C - каждое данное в результате будет представлено только
своим  именем, т.е. результатом будет не список данных, а спи-
сок значений;
     ! - каждое вычислимое данное будет вычислено;

                            - 15 -
     @ - каждое косвенное данное будет заменено  своим  рефе-
рентом;
     * - символ "*" на месте значения будет заменен именем те-
кущего фрейма;
     А - данные наследуются из всех релевантных фреймов;
     H - АКО-наследование разрешено;
     1 - $DEFAULT-наследование разрешено.

     Механизмы  наследования   реализуются   функциями   FGET,
FGET1, FGETN.
     FGET1 - есть наследование вдоль АКО связи, причем при об-
наружении первого референта в сети  фреймов  вдоль  АКО  связи
процесс наследования прекращается.
     FGETN - наследование осуществляется по всем фреймам вдоль
АКО связи.

     Hиже приведен алгоритм работы FGET1 (для FGET  п.3  алго-
ритма  отсутствует,  для FGETN п.3 расширен возможностью обра-
ботки всего множества запросов для АКО).

     1.  Если поступил запрос во фрейм :FRAME, слот :SLOT, ас-
пект $VALUE и данные обнаружены, то перейти  к  п.4,  иначе  к
п.2.
     2.  Выполнить  запрос во фрейм :FRAME, слот :SLOT, аспект
$DEFAULT. Если данные обнаружены, то перейти к п.1 и  последо-
вательно  выполнять запросы во фрейм :FRAME, причем :FRAME бу-
дет каждый раз связываться с очередным данным,  полученным  на
данном шаге 3 до тех пор, пока не будет удовлетворен запрос. В
противном случае перейти к п.4.
     3. Результат запроса NIL. Перейти к п.5.
     4. Список выбранных данных связать со значением  перемен-
ной  :VALUE,  выполнить  присоединенные  процедуры  из аспекта
$IF-GETED по правилам,  предусмотренным  в  п.2.3.  инструкции
(выполнение  присоединенных процедур будем называть в дальней-
шем побочным эффектом запроса).  Результат  запроса  -  список
выбранных данных. Перейти к п.6.
     5. Конец работы.

Примечания:
     1)  Вышеописанный алгоритм не включает описание того воз-
действия на выбор данных при выполнении запроса, которое оказы-
вают  комментарии  и сообщения, присоединенные к данным из ас-
пектов $VALUE и $DEFAULT (в дальнейшем будем называть это воз-
действие  редактированием  или  фильтрацией  запроса).
     2) Если в запросе :FACET отличен от $VALUE или  $DEFAULT,
то  выполняется  обычная выборка данных без наследования и по-
бочных эффектов.
     3) Существуют функции FGET-, FGET1-, FGETN-, которые ана-
логичны  FGET,  FGET1, FGETN, но без побочного эффекта и филь-
трации запроса.

     Функция
 (FGET-SEL <имя фрейма> <имя слота> <имя аспекта> [ <ключи>]
                                       { <метка> <сообщ> } )
работает так же, как и FGET, но извлекает  только  те  данные,
которые содержат указанные в обращении комментарии.

     Функция
 (FGETIND <имя фрейма1> ( { <отношение> } ) [ <имя аспекта>
            [ <ключи> ] ] )
осуществляет  извлечение  данных  листьевых  фреймов из дерева
фреймов, связанных указанными отношениями. Более точно:  пусть

                            - 16 -
имеется дерево фреймов вида:
              (F0 R1 (F1,1 ...) ... R1 (F1,N1))

где FI,J - фреймы (0<I< К-1, 1<J<NI);
    FК,J - любые данные в смысле FRL (в том числе и  фреймы)
(1<J<NК).
     Тогда в результате выполнения (FGETIND F0 (R1 R2 ... RК))
будет получен результат (FК,1 ... FК,NК). По-умолчанию предпо-
лагается, что все данные ищутся в аспекте $VALUE.

     Функция
 (FQUERY <f - имя фрейма> <s - имя слота> <a - имя аспекта>
         <ref - критерий> <field - область поиска>
         <relation - отношение>)
осуществляет поиск на сети фреймов. Перед началом поиска опре-
деляются: область поиска (множество объектов-кандидатов), объ-
ект поиска и критерий поиска.
     Основные случаи:

1. f=NIL & ref<>NIL
     Область поиска определяется следующим образом:
     Если field=NIL, то область поиска - по всем активным
фреймам.
     Если field - атом, то по всем вершинам дерева отношения
relation с корнем в field.
     Если field - непустой список, то если relation задано -
по всем вершинам всех деревьев отношения relation с корнями в
списке field; если же relation не задано, то по всем элементам
списка field.
     Объект поиска - фрейм.
     Критерий поиска следующий:
     Если ref - атом, то он должен содержаться среди значений
слота s аспекта a фрейма-кандидата.
     Если ref - предикат, то он должен выполняться хотя-бы на
одном значении слота s аспекта a фрейма-кандидата.
     Результат - список имен фреймов.

2. f<>NIL & s=NIL
     Область поиска - все слоты фрейма f.
     Объект поиска - слот.
     Критерий поиска - в аспекте a слота-кандидата фрейма f
должно содержаться данное, удовлетворяющее ref (аналогично
предыдущему случаю - см. выше).
     Результат - список имен слотов.

3. f<>NIL & s<>NIL & a=NIL
     Результат - структура слота s фрейма f.

4. f<>NIL & s<>NIL & a<>NIL
     Область поиска - все данные фрейма f слота s аспекта a.
     Объект поиска - данное или истинностное значение.
     Результат поиска следующий:
если ref - атом, то T только в том случае, когда этот атом ref
содержится среди значений слота s фрейма f.
если ref - предикат, то список всех данных, на которых этот
предикат истинен.


                2.9. Мэтчинг на сети фреймов.

     Существует  множество различных понятий мэтчинга: строко-
вый, списковый, структурный, синтаксический,  семантический  и

                            - 17 -
т.д.  Мы  рассматриваем  мэтчинг  фреймов,  который  является
структурным и семантическим. За основу взято определение  мэт-
чинга из [Cha 80]: "фрейм F1 сопоставим (или мэтчится) с фрей-
мом F2 если он может быть его экземпляром, т.е.  фрейм  F1  не
содержит  таких  свойств,  которые  противоречили бы известным
свойствам фрейма F2", однако в этом  "определении"  не  совсем
ясно,  что  означает  "противоречие свойств", поэтому в данном
отчете будем придерживаться собственного определения  мэтчинга
на фреймах, которое приводится в п. 2.9.2.


                     2.9.1. Дескрипторы.

     В  мэтчинге  могут участвовать объекты трех типов: термы,
фреймы и дескрипторы.
     Объекты, не являющиеся фреймами или дескрипторами, счита-
ются термами.
     Объект типа дескриптор имеет структуру, сходную со струк-
турой фрейма, однако на уровне слотов и значений слотов он мо-
жет иметь альтернативные, конъюнктивные, дизъюнктивные и нега-
тивные элементы. Кроме этого, значением слота в  свою  очередь
может быть дескриптор.
     Синтаксис дескриптора:

     <дескриптор> ::= ( <имя дескриптора> { <слот> } )
     <имя дескриптора> ::= <атом>
     <слот> ::= ( <имя слота> { <аспект> } ) | <функтор>
     <функтор> ::= ALT | OR | NOT
     <имя слота> ::= <отношение> | <свойство> | SELF
     <отношение> ::= <атом>
     <свойство> ::= <атом>
     <аспект> ::= ( <имя аспекта> { <данное> } )
     <имя аспекта> ::= <атом>
     <данное> ::= ( <имя данного> { <комментарий> } ) |
                  <функтор>

     <имя данного> ::= <значение>
     <значение> ::= <атом> | <d-пара>
             | <вызов LISP- или FRL-функции>

             | <имя фрейма> | <фрейм>

             | <имя дескриптора> | <дескриптор>

     <комментарий> ::= ( <имя комментария> { <сообщение> } )
     <имя комментария> ::= <метка>
     <метка> ::= <атом>
     <сообщение> ::= <с-выражение>

     Дескриптор и аспект дескриптора могут иметь альтернативы.
Альтернативой в дескрипторе (или в аспекте)  называется  мини-
мальная  группа слотов (или значений), ограниченная функторами
ALT или границами дескриптора (или аспекта).  Альтернатива,  в
свою  очередь, представляет собой КНФ, где отдельные конъюнкты
представляются либо в виде слотов (или значений), возможно,  с
отрицаниями,  т.е. функторами NOT, либо в виде дизъюнкции сло-
тов (или значений), также возможно с отрицаниями. Дизъюнкты  в
конъюнкте разделяются функторами OR. Пример дескриптора приве-
ден в п.2.9.3.
     Приоритеты функторов задаются таблицей 2.1.
.
                            - 18 -


                                                 Таблица 2.1.
                    Приоритеты функторов

-------------------------------------------------------------
|    операция    |     функтор       |      приоритет       |
-------------------------------------------------------------
| отрицание      |      NOT          |          4           |
-------------------------------------------------------------
| дизъюнкция     |      OR           |          3           |
-------------------------------------------------------------
| конъюнкция     | выражается неявно |          2           |
|                | в виде последова- |                      |
|                | тельности слотов  |                      |
|                | или значений      |                      |
-------------------------------------------------------------
| альтернатива   |       ALT         |                      |
-------------------------------------------------------------
     Основной функцией MFRL/PC, которая  осуществляет  процесс
сопоставления,  является  функция  FМАТCH?  (см. Приложение 1,
п.1.5).
     Для работы с объектами типа дескриптор предусмотре-
ны  специальные  функции  DEDESCR,  DEDESCRQ,  DESCRS, DNAME?,
DESCR, DINSTANCE, синтаксис которых аналогичен  соответственно
синтаксису  функций DEFRAME, DEFRAMEQ, FRAMES, FNАМЕ?, FRAME и
FINSTANCE (см. Приложение 1).


                2.9.2. Определение мэтчинга.

     Объект F1 сопоставим (или мэтчится) с объектом F2  (обоз-
начение:  F1  М  F2), если выполнено одно из условий (через x*
обозначается экземпляр объекта x, порождаемый в процессе  мэт-
чинга):

     а) F1 - фрейм,  F2 - фрейм,  причем  фрейм  F1   является
АКО-экземпляром фрейма F2.

     б) F1 - фрейм, F2 - фрейм, причем фрейм  F1  не  является
АКО-экземпляром  фрейма  F2  и  для каждого значения V2 любого
слота S фрейма F2 может быть найдено значение V1 в одноименном
слоте S фрейма F1, которое с ним сопоставимо, т.е. V1 М V2.

     в) F1 - фрейм, F2 - дескриптор,  причем  F1 сопоставим (в
смысле условия б)) хотя-бы с одной  альтернативой  фрейма  F2.
Процессом сопоставления фрейма с альтернативой дескриптора уп-
равляют функторы (см. пример в п. 2.9.3).

     г) F1 - фрейм, F2 - терм, причем F2 совпадает со значени-
ем  слота  SELF  фрейма  F1,  т.е. F2 = (FGET F1 'SELF '$VALUE
'(Е))

     д) F1 - терм, F2 - фрейм, причем  терм  F1  удовлетворяет
предикатам  из  аспекта  $REQUARE  слота  SELF фрейма F2, т.е.
(FCHECK? F2 'SELF F1) = Т

     е) F1 - терм, F2 - дескриптор, причем терм F1  удовлетво-
ряет предикатам из аспекта $REQUARE слота SELF экземпляра дес-
криптора F2, т.е. (FCHECK? F2* 'SELF F1) = Т.

     ж) F1 - терм, F2 - терм, причем F1 = F2.

                            - 19 -

     Заметим, что с пустым фреймом или дескриптором  сопостав-
ляется любой объект.
     Слот  SELF используется в концевых точках процесса сопос-
тавления, когда  необходимо  сопоставить  терм  и  нетерм.  Он
как-бы представляет весь фрейм в целом.


               2.9.3. Результат сопоставления.

     Результатом сопоставления является истина (т.е. атом Т) в
случае успешного сопоставления и ложь (т.е. атом NIL) - в слу-
чае неуспешного.
     Однако, в результате сопоставления, как правило,  необхо-
димо знать не только бинарный ответ: сопоставилось - не сопос-
тавилось, но и причины этого ответа, т.е. какие слоты и значе-
ния сопоставились или не сопоставились. Для этой цели в систе-
ме  MFRL/PC  введены   глобальные   переменные   *MATCHED*   и
*UNMATCHED*.
     В  переменной  *MATCHED* формируется список пар сопоста-
вившихся объектов, причем группа  пар,  относящихся  к  одному
слоту, предваряется именем этого слота.
     В переменной *UNMATCHED* формируется список пар не сопос-
тавившихся объектов, причем группа пар, относящихся  к  одному
слоту, также предваряется именем этого слота.
     Пример. Пусть даны фрейм F и дескриптор D:

                F: (F (S1 ($VALUE (V1) (V2)))
                      (S2 ($VALUE (V1) (V3)))
                      (S3 ($VALUE (V2) (V3))) )

                D: (D (S1 ($VALUE (V1) (V2)))
                      (S2 ($VALUE (V1) OR (V2)))
                      (S3 ($VALUE (V2) NOT (V3)))
                  ALT (S1 ($VALUE (V3) OR (V1)))
                      (S2 ($VALUE (V2)))
                   OR (S3 ($VALUE (V3))) )

     Тогда результатом мэтчинга F М D будет Т, причем:

          *MATCHED* = ((F . D)
                    S3 (V3 . V3)
                    S1 (V1 . V1) (V3 . V3) (V2 . V2)
                    S2 (V1 . V1)
                    S1 (V2 . V2) (V1 . V1) )

        *UNMATCHED* = ((V2 . V3)
             С2 (V3 . V2) (V1 . V2) (V2 . V3) (V1 . V3)
             С3 (V2 . V3) (V1 . V2))
     Ниже  приведена та часть дескриптора D, с которой успешно
сопоставился фрейм F:

                 (Д (S1 ($VALUE (V3) OR (V1)))
                    (S3 ($VALUE (V3))) )

     Предлагаемый формализм дескрипторов с функторами позволя-
ет на практике, например, при создании экспертных систем, реа-
лизовывать в правилах вывода вполне достаточный  для  эксперта
класс условий.

  2.10. Трассировка (организация глобальных присоединенных
                          процедур)

                            - 20 -

     В  FRL  имеется  возможность трассировки, т.е. выполнения
определенных программ пользователя, при внесении  изменений  в
любой  фрейм,  слот,  аспект, данное, комментарий и сообщение.
Для этой цели в системе имеются  специальные  средства,  через
которые  осуществляется  воздействие  пользователя  на  работу
FRL-процессора. К таким средствам относится процедура  FTRACE.
С  помощью FTRACE пользователь может подключать к системе про-
цедуры (будем называть их  трассирующими),  которые  управляют
запуском присоединенных процедур. Трассирующие процедуры могут
быть присоединены к любому фрейму с заданной  структурой.  Для
подключения  этих  процедур к работе FRL-процессора необходимо
выполнить функцию:  (FTRACE  <имя-фрейма>  <список-пар>),  где
<имя-фрейма> - имя фрейма, содержащего трассирующие процедуры,
а <список-пар> - список  вида  ((<мета-имя-подструктуры><усло-
вие> ... ).
     <Мета-имя-подструктуры>  -  это  есть FRAME, SLOT, VALUE,
LABEL или MESSAGE.
     <Условие>  представляет   один   из   следующих   атомов:
IF-ADDED, IF-REMOVED, IF-GETED, что интерпретируется следующим
образом:

     IF-ADDED - трассирующие процедуры запускаются при  добав-
лении в систему структуры с соответствующим мета-именем;
     IF-REMOVED  - трассирующие процедуры запускаются при уда-
лении из системы структуры с соответствующим мета-именем;
     IF-GETED - трассирующие процедуры запускаются при  извле-
чении из сети структуры с соответствующим мета-именем.
     Можно  использовать  и такое обращение: (TRACE <имя фрей-
ма>). В этом случае будут об'явлены трассирующими все процеду-
ры из фрейма <имя фрейма>.
     Для  отключения  режима  трассировки следует использовать
функцию  FUNTRACE.  Синтаксис:  (FUNTRACE).  Ниже   приводится
структура фрейма, используемого процедурой FTRACE.

  (<имя фрейма>
     (FRAME ($IF-ADDEED <процедуры, выполняемые при занесе-
                         нии нового фрейма в систему>)
            ($IF-REMOVED <процедуры,выполняемые при удалении
                         фрейма из системы>)
            ($IF-GETED <процедуры, извлекающие информацию из
                        фрейма>)
     )
     (SLOT ($IF-ADDED <процедуры, выполняемые при занесении
                       нового слота в какой-нибудь фрейм>)
           ($IF-REMOVED <процедуры, выполняемые при удалении
                         слота из какого-либо фрейма>)
           ($IF-GETED <процедуры, извлекающие информацию из
                       слота>)
     )
     (FACET ($IF-ADDED <процедуры, выполняемые при занесении
                        нового аспекта в какой-либо слот>)
            ($IF-REMOVED <процедуры, выполняемые при удалении
                          аспекта из какого-либо слота>)
            ($IF-GETED <процедуры, извлекающие значение из
                        аспекта>)
     )
     (VALUE ($IF-ADDED <процедуры, выполняемые при занесении
                        нового значения в какой-либо аспект>)
            ($IF-REMOVED <процедуры, выполняемые при удалении
                           значения из какого-либо аспекта>)
            ($IF-GETED <процедуры, извлекающие значение из

                            - 21 -
                        данного>)
     )
     (LABEL ($IF-ADEED <процедуры, выполняемые при занесении


                     нового комментария в какое-либо данное>)
            ($IF-REMOVED <процедуры, выполняемые при удалении
                          комментария из какого-либо данного>)
            ($IF-GETED <процедуры, извлекающие комментарий из
                        какого-либо данного>)
     )
     (MESSAGE ($IF-ADDED <процедуры, выполняемые при занесе-
                          нии нового сообщения в какой-либо
                          комментарий>)
              ($IF-REMOVED <процедуры, выполняемые при уда-
                            лении сообщения из какого-либо
                            комментария>)
     )
   )

Примечание.
     Все  компоненты указанной фрейм-структуры носят факульта-
тивный характер.



 2.11. Интерфейс с внешними запоминающими устройствами (ВЗУ)

    Пользователь систем  MFRL/PC  может  хранить  все  желаемые
фреймы и процедуры в базе  фреймов  на  внешнем  носителе.  Все
фреймы  и  процедуры загружаются в оперативную память автомати-
чески при первом упоминании. Сохранение объектов в базе фреймов
управляется функциями FSАVЕ,  PSАVЕ и FPSАVЕ (см. Приложение 1,
п.1.6).
    ---------------------
    Подробное описание работы с внешними носителями представле-
но в документации по системе MWM/PC.
    ---------------------

       2.11.1. Взаимодействие с виртуальной базой объектов

     В MFRL/PC принято деление фреймов на активные  и  пассив-
ные.  Активными  называются  фреймы, находящиеся в оперативной
памяти, как правило, это фреймы, созданные  в  текущем  сеансе
работы  либо  загруженные из ВЗУ. Фреймы, находящиеся только в
ВЗУ, называются пассивными.
    На ВЗУ  фреймы можно хранить либо в последовательном файле,
либо в виртуальной базе объектов (ВБО).  Под ВБО понимается ин-
формационный набор на ВЗУ с возможностью ассоциативного поимен-
ного доступа к своим объектам, имеющим списковую структуру.
     Достоинством  хранения  фреймов или процедур в последова-
тельном файле является возможность их редактирования каким-ли-
бо мощным системным редактором, недостатком - сложность и неу-
добство динамического взаимодействия с FRL.
     Достоинством хранения  объектов в ВБО является возможность
загрузки и выгрузки этих объектов по указанию  только  их  имен
(при этом нет необходимости знать имена файлов,  в которых хра-
нятся эти объекты).  При работе с ВБО обеспечивается  автомати-
ческая загрузка фреймов и процедур в оперативную память. Недос-
татком является отсутствие возможности использования какого-ли-
бо  системного  редактора  за исключением встроенного редактора
LISP.

                            - 22 -
     Процесс активации пассивных фреймов (загрузки их из ВЗУ в
оперативную память) может проходить либо по явному  требованию
пользователя  из  конкретного файла либо автоматически из ВБО.
     Деактивация активных фреймов и/или процедур  сохранение  в
ВБО  или в файле производится только по явному указанию пользо-
вателя.  Как активация, так и деактивация возможны лишь при ус-
ловии,  что  требуемый  раздел базы данных или последовательный
файл предварительно открыт.


     2.11.2.  Создание и использование библиотечных файлов

     Библиотечные  файлы предоставляют возможности хранения на
диске множества процедур, которые будут  автоматически  загру-
жатся с диска загрузки в оперативную память.
     Имея библиотечный файл в текущей директории, вы получаете
возможность доступа ко всем  функциям,  переменным  и  спискам
свойств  без их предварительной загрузки в оперативную память.
Для каждой функции, которая при обращении к ней не  найдена  в
оперативной памяти, будет происходить ее поиск в открытых биб-
лиотечных файлах с последующей загрузкой в оперативную память.
.
                            - 23 -






















                     П Р И Л О Ж Е Н И Я

.
                            - 24 -


                 П1.1. Основные обозначения

          П1.1.1 Обозначения для системных функций


     p_n  - имя LISP-процедуры (procedure's name)
     l_n  - имя списка (list name)
     pl_n - имя списка свойств (propety list name)
     f_n  - имя файла (file name)

     e_list - список, элементами которого являются S-выражения
(expression list)
     k_list - список, элементами которого являются ASCII  коды
и отдельные символы. (keyboard list)
     p_list - список свойств (propety list)

     r_a - адрес ячейки в оперативной памяти (RAM address)
     expr - S-выражение (expression)
     string - строка muLISP
     atom - атом muLISP
     n - целое (number)
     list - список
     byte - байт (целое от 0 до 255)
     flag - флаг (переменная, определенная на множестве значе-
ний: T, NIL)

     В фигурные скобки будем заключать альтернативные аргумен-
ты, в квадратные - факультативные *).

---------------------------------------------------------------
     *) Примечание: Если факультативный аргумент опускается, а
справа  от него находится хотя бы один действительный (не опу-
щенный) аргумент, то в качестве значения факультативного аргу-
мента следует явно указать NIL.
--------------------------------------------------------------


          П1.1.2 Обозначения для FRL  функций


     В таблицах, приводимых  ниже  будем  использовать  следующие
обозначения для FRL-объектов:

   f - имя фрейма;               fs - фрейм-структура;
   s - имя слота;                ss - слот;
   а - имя аспекта;              as - аспект;
   v - имя данного;              vs - данное;
   l - имя комментария (метка);  ls - комментарий;
   m - имя сообщения;            мs - сообщение;

   pnl - список имен процедур (procedure name  list)
   fnl - список имен фреймов  (frame     name  list)
   fvl - список данных FRL    (frame     value list)
   fn  - имя функции (function name)

----------------------------------------------------------------
     *) Примечание: Факультативные аргументы FRL функций следуют
за обязательными и в данном описании отделяются двоеточием.
Альтернативные аргументы указаны в фигурных скобках.
---------------------------------------------------------------

                            - 25 -


.
                            - 26 -

             П1.2.1.  Константы MFRL/PC

╒══════════════════════╤═════════════════════════════════════╕
│      Синтаксис       │              Семантика              │
╞══════════════════════╪═════════════════════════════════════╡
│ *AKO-INSTANCE*       │   Список свойств для хранения имен  │
│                      │ инверсных отношений                 │
│                      │   (CDR '*AKO-INSTANCE*) => ((AKO .  │
│                      │ INSTANCE) (INSTANCE . AKO))         │
├──────────────────────┼─────────────────────────────────────┤
│ AKO                  │ AKO                                 │
│ INSTANCE             │ INSTANCE                            │
│ $VALUE               │ $VALUE                              │
│ $DEFAULT             │ $DEFAULT                            │
│ $IF-NEEDED           │ $IF-NEEDED                          │
│ $IF-REMOVED          │ $IF-REMOVED                         │
│ $IF-ADDED            │ $IF-ADDED                           │
│ $IF-GETED            │ $IF-GETED                           │
│ $IF-ADD              │ $IF-ADD                             │
│ $IF-REM              │ $IF-REM                             │
│ $IF-GET              │ $IF-GET                             │
│ $IF-INSTANTIATED     │ $IF-INSTANTIATED                    │
│ $IF-REQUIRE          │ $IF-REQUIRE                         │
╘══════════════════════╧═════════════════════════════════════╛


             П1.2.2.  Стеки MFRL/PC

 ╒══════════════════╤══════════════════════════╤═════════════════════╕
 │ Имя списка св-в  │ Назначение               │ Используется ф-ями  │
 ╞══════════════════╪══════════════════════════╪═════════════════════╡
 │ *FRAMES*         │ Содержит имена активных  │ DEFRAME, FRESET,    │
 │                  │ фреймов                  │ FPRINT, FASSERT,    │
 │                  │                          │ FSAVE, DEFRAMEQ,    │
 │                  │                          │ FASSERTQ, FDESTROY  │
 ├──────────────────┼──────────────────────────┼─────────────────────┤
 │ *PROCEDURES*     │ Содержит имена активных  │ PASSERT, PRESET,    │
 │                  │ процедур                 │ PSAVE, PASSERTQ     │
 ├──────────────────┼──────────────────────────┼─────────────────────┤
 │ *FGENAMELIST*    │ Содержит информацию для  │ FGENAME, FGETNAME   │
 │  (переменная)    │ генерации уникальных имен│                     │
 │                  │ фреймов (реализован как  │                     │
 │                  │ список свойств).         │                     │
 ╘══════════════════╧══════════════════════════╧═════════════════════╛

             П1.2.3.  Глобальные переменные MFRL/PC

╒══════════════════════╤═════════════════════════════════════╕
│      Синтаксис       │              Семантика              │
╞══════════════════════╪═════════════════════════════════════╡
│ *FRAME*              │   Тело фрейма сразу после           │
│                      │ FRAME? или FNAME?                   │
├──────────────────────┼─────────────────────────────────────┤
│ *FNAME*              │   Имя фрейма сразу после            │
│                      │ FRAME? или FNAME?                   │
├──────────────────────┼─────────────────────────────────────┤
│ *DESCR*              │   Тело дескриптора сразу после      │
│                      │ DNAME?                              │
├──────────────────────┼─────────────────────────────────────┤
│ *DNAME*              │   Имя дескриптора сразу после       │
│                      │ DNAME?                              │
├──────────────────────┼─────────────────────────────────────┤

                            - 27 -
│ *MATCHED*            │   Список сопоставившихся объектов   │
│                      │ после FMATCH?                       │
├──────────────────────┼─────────────────────────────────────┤
│ *UNMATCHED*          │   Список несопоставившихся объектов │
│                      │ после FMATCH?                       │
╘══════════════════════╧═════════════════════════════════════╛

.
                            - 28 -



          П1.3. Изменение сети фреймов и процедур.

╒══════════════════════╤═════════════════════════════════════╕
│      Синтаксис       │              Семантика              │
╞══════════════════════╪═════════════════════════════════════╡
│ (PASSERT fn bd)      │   Определяется или переопределяется │
│                      │ процедура с именем fn и телом bd.   │
│                      │ Имя процедуры заносится в стек      │
│                      │ *PROCEDURES*                        │
│                      │   Результат - имя процедуры.        │
├──────────────────────┼─────────────────────────────────────┤
│ (PASSERTQ fn bd)     │   То же что и PASSERT, но при обра- │
│                      │ щении аргументы не вычисляются.     │
├──────────────────────┼─────────────────────────────────────┤
│ (DEFRAME f : ss1 ... │   Создается новый фрейм, содержащий │
│   ssn)               │ указанные слоты. Результат - имя    │
│                      │ созданного фрейма. Присоединенные   │
│                      │ процедуры не активизируются.        │
├──────────────────────┼─────────────────────────────────────┤
│ (DEFRAMEQ f : ss1    │   Аналог DEFRAME, но аргументы      │
│            ... ssn   │ DEFRAMEQ не вычисляются при обраще- │
│                      │ нии.                                │
├──────────────────────┼─────────────────────────────────────┤
│ (FASSERT f : ss1 ... │   Создается новый или пополняется   │
│                  ssn │ старый фрейм. Результат- имя фрей-  │
│                      │ ма. Присоединенные процедуры выпол- │
│                      │ няются.                             │
├──────────────────────┼─────────────────────────────────────┤
│ (FASSERTQ f : ss1    │   Аналог FASSERT, но аргументы      │
│          ... ssn)    │ FASSERTQ не вычисляются при обраще- │
│                      │ нии.                                │
├──────────────────────┼─────────────────────────────────────┤
│ (FRENAME f1 : f2)    │   Фрейм с именем f1 переименовыва-  │
│                      │ ется во фрейм с именем f2. Резуль-  │
│                      │ тат - новое имя.                    │
├──────────────────────┼─────────────────────────────────────┤
│ (FNAME {f | fs})     │   Результат - имя фрейма. Если та-  │
│                      │ кой фрейм не найден - он создается. │
├──────────────────────┼─────────────────────────────────────┤
│ (FRAME {f | fs})     │   Результат - указатель на          │
│                      │ фрейм-структуру. Если фрейм не най- │
│                      │ ден - он создается                  │
├──────────────────────┼─────────────────────────────────────┤
│ (FPUT- f : s a v l   │   В тело фрейма f, добавляется слот │
│ m)                   │ s, аспект a, данное v, метка l,     │
│                      │ комментарий m.                      │
│                      │   Если какая либо из структур:      │
│                      │ f,s,a, v,l,m уже существовала, то в │
│                      │ нее либо добавляется новая информа- │
│                      │ ция, либо эта структура остается    │
│                      │ без изменения.                      │
│                      │   Если к моменту выполнения FPUT-   │
│                      │ какая либо из структур: f,s,a,v,l,m │
│                      │ не существовала - она создается.    │
│                      │   Присоединенные процедуры не вы-   │
│                      │ полняются                           │
├──────────────────────┼─────────────────────────────────────┤
│ (FPUT-STRUCTURE- f)  │   То же, что и в FPUT-, но послед-  │
│ (FPUT-STRUCTURE- f   │ ний аргумент обращения трактуется   │

                            - 29 -
│ ss)                  │ как готовая соответствующая         │
----------------------------------------------------------------
│ as)                  │ во фрейм                            │
│ (FPUT-STRUCTURE- f s │                                     │
│ a vs)                │                                     │
│ (FPUT-STRUCTURE- f s │                                     │
│ a v ls)              │                                     │
│ (FPUT-STRUCTURE- f s │                                     │
│ a v l ms)            │                                     │
├──────────────────────┼─────────────────────────────────────┤
│ (FPUT f : s a v l m) │   В тело фрейма f, добавляется слот │
│                      │ s, аспект a, данное v, метка l,     │
│                      │ комментарий m.                      │
│                      │   Если какая либо из структур:      │
│                      │ f,s,a, v,l,m уже существовала, то в │
│                      │ нее либо добавляется новая информа- │
│                      │ ция, либо эта структура остается    │
│                      │ без изменения.                      │
│                      │   Если к моменту выполнения FPUT-   │
│                      │ какая либо из структур: f,s,a,v,l,m │
│                      │ не существовала - она создается.    │
│                      │   Присоединенные процедуры выполня- │
│                      │ ются                                │
├──────────────────────┼─────────────────────────────────────┤
│ (FPUTV f s v)        │   =(FPUT f s $VALUE v)              │
├──────────────────────┼─────────────────────────────────────┤
│ (FPUT-STRUCTURE f)   │   То же, что и в FPUT, но последний │
│ (FPUT-STRUCTURE f    │ аргумент обращения трактуется как   │
│ ss)                  │ готовая соответствующая   структу-  │
│ (FPUT-STRUCTURE f s  │ ра, которая будет добавлена во      │
│ as)                  │ фрейм.                              │
│ (FPUT-STRUCTURE f s  │                                     │
│ a vs)                │                                     │
│ (FPUT-STRUCTURE f s  │                                     │
│ a v ls)              │                                     │
│ (FPUT-STRUCTURE f s  │                                     │
│ a v l ms)            │                                     │
├──────────────────────┼─────────────────────────────────────┤
│ (FPUT-STRUC f sb)    │   =(FPUT-STRUCTURE f sb)            │
├──────────────────────┼─────────────────────────────────────┤
│ (FPUT-STRUC f s ab)  │   =(FPUT-STRUCTURE f s ab)          │
├──────────────────────┼─────────────────────────────────────┤
│ (FPUT-STRUC f s a d) │   =(FPUT-STRUCTURE f s a d)         │
├──────────────────────┼─────────────────────────────────────┤
│ (FPUT-STRUC f s a v  │   =(FPUT-STRUCTURE f s a v c)       │
│ c)                   │                                     │
├──────────────────────┼─────────────────────────────────────┤
│ (FPUT-STRUC f s a v  │   =(FPUT-STRUCTURE f s a v l m)     │
│ l m)                 │                                     │
├──────────────────────┼─────────────────────────────────────┤
│ (FDELETE f : s a v l │   То же, что и FREMOVE, но присое-  │
│ m)                   │ диненные процедуры не активизируют- │
│                      │ ся и результат - указатель на изме- │
│                      │ ненную подструктуру фрейма.         │
├──────────────────────┼─────────────────────────────────────┤
│ (FDEL-STRUCTURE f    │   Удаляет подструктуру фрейма f,    │
│ ss)                  │ локализуемую остальными аргументами │
│ (FDEL-STRUCTURE f s  │ обращения. Результат - измененная   │
│ as)                  │ подструктура или NIL , если удале-  │
│ (FDEL-STRUCTURE f s  │ ния не произошло. Присоединенные    │
│ a vs)                │ процедуры не выполняются. Число ар- │
│ (FDEL-STRUCTURE f s  │ гументов - от 1 до 6                │

                            - 30 -
│ a v ls)              │                                     │
│ (FDEL-STRUCTURE f s  │                                     │
│ a v l ms)            │                                     │
├──────────────────────┼─────────────────────────────────────┤
│ (FREMOVE f : s a v l │   Удаляет из фрейма подструктуру,   │
│          m)          │ локализуемую аргументами обращения. │
│                      │ Последний аргумент обращения задает │
│                      │ имя удаляемой подструктуры. Число   │
│                      │ аргументов - от 1 до 6. Результат - │
│                      │ последний аргумент в обращении.     │
│                      │ Присоединенные процедуры выполняют- │
│                      │ ся.                                 │
├──────────────────────┼─────────────────────────────────────┤
│ (FREM-STRUCTURE- f   │   То же что и FDEL-STRUCTURE, с той │
│ ss)                  │ разницей что присоединенные проце-  │
│ (FREM-STRUCTURE- f s │ дуры не выполняются                 │
│ as)                  │                                     │
│ (FREM-STRUCTURE- f s │                                     │
│ a vs)                │                                     │
│ (FREM-STRUCTURE- f s │                                     │
│ a v ls)              │                                     │
│ (FREM-STRUCTURE- f s │                                     │
│ a v l ms)            │                                     │
├──────────────────────┼─────────────────────────────────────┤
│ (FREM-STRUC f s a v  │   =(FREM-STRUCTURE f s a v l m)     │
│ l m)                 │                                     │
├──────────────────────┼─────────────────────────────────────┤
│ (FREP-STRUCTURE f    │   Последний аргумент обращения      │
│ ss)                  │ трактуется как структура соответст- │
│ (FREP-STRUCTURE f s  │ вующего уровня. Она полностью заме- │
│ as)                  │ няет во входном фрейме соответству- │
│ (FREP-STRUCTURE f s  │ ющую структуру. Результат - изме-   │
│ a vs)                │ ненная подструктура. Число аргумен- │
│ (FREP-STRUCTURE f s  │ тов - от 1 до 5. Присоединенные     │
│ a v ls)              │ процедуры выполняются.              │
│ (FREP-STRUCTURE f s  │                                     │
│ a v l ms)            │                                     │
├──────────────────────┼─────────────────────────────────────┤
│ (FREP-STRUCTURE- f   │   Последний аргумент обращения      │
│ ss)                  │ трактуется как структура соответст- │
│ (FREP-STRUCTURE- f s │ вующего уровня. Она полностью заме- │
│ as)                  │ няет во входном фрейме соответству- │
│ (FREP-STRUCTURE- f s │ ющую структуру. Результат - изме-   │
│ a vs)                │ ненная подструктура. Число аргумен- │
│ (FREP-STRUCTURE- f s │ тов - от 1 до 5. Присоединенные     │
│ a v ls)              │ процедуры не выполняются.           │
│ (FREP-STRUCTURE- f s │                                     │
│ a v l ms)            │                                     │
├──────────────────────┼─────────────────────────────────────┤
│ (FREP-STRUC f s a v  │   =(FREP-STRUCTURE f s a v l m)     │
│ l m)                 │                                     │
├──────────────────────┼─────────────────────────────────────┤
│ (FINSTANTIATE f1 :   │   Создается экземпляр фрейма f1 с   │
│ f2)                  │ именем f2. Если f2 опущено, то соз- │
│                      │ дается фрейм с системным именем, в  │
│                      │ создаваемый экземпляр помещаются    │
│                      │ также значения, вырабатываемые про- │
│                      │ цедурами, присоединенными к аспек-  │
│                      │ там $IF-INSTANTIATED каждого слота  │
│                      │ фрейма f. Результат - имя созданно- │
│                      │ го фрейма.                          │
├──────────────────────┼─────────────────────────────────────┤

                            - 31 -
│ (FCLEAN f s : a)     │   Удаляет из фрейма f слота s ас-   │
│                      │ пекта a все данные, которые не      │
│                      │ удовлетворяют процедурам, наследуе- │
│                      │ мым из аспекта $REQUIRE. Если ас-   │
│                      │ пект a опущен, то a=$VALUE. Возвра- │
│                      │ щает список удаленных данных.       │
├──────────────────────┼─────────────────────────────────────┤
│ (FINSTANCE f sb*)    │   Создает экземпляр фрейма f со     │
│                      │ слотами s1 s2 ... sN.               │
├──────────────────────┼─────────────────────────────────────┤
│ (FREVADD s)          │   Создает обратную ссылку s из      │
│                      │ фрейма :VALUE на фрейм :FRAME (в    │
│                      │ аспекте :FACET).                    │
├──────────────────────┼─────────────────────────────────────┤
│ (FREVREM s)          │   Удаляет обратную ссылку s из      │
│                      │ фрейма :VALUE на фрейм :FRAME (в    │
│                      │ аспекте :FACET).                    │
├──────────────────────┼─────────────────────────────────────┤
│ (FORWADD s)          │   Создает прямую ссылку s из фрейма │
│                      │ :VALUE на фрейм :FRAME (в аспекте   │
│                      │ :FACET).                            │
├──────────────────────┼─────────────────────────────────────┤
│ (FORWREM s)          │   Удаляет прямую ссылку s из фрейма │
│                      │ :VALUE на фрейм :FRAME (в аспекте   │
│                      │ :FACET).                            │
│                      │                                     │
├──────────────────────┼─────────────────────────────────────┤
│ (PRESET : pnl)       │   Указанные процедуры удаляются из  │
│                      │ системы. Результат список имен уда- │
│                      │ ленных процедур. Если pnl в обраще- │
│                      │ нии опущен, то считается, что       │
│                      │ pnl=*PROCEDURES* .                  │
├──────────────────────┼─────────────────────────────────────┤
│ (FRESET : fnl)       │   Указанные фреймы затираются в     │
│                      │ оперативной памяти. Присоединенные  │
│                      │ процедуры не выполняются. Результат │
│                      │ - список имен затертых фреймов. Ес- │
│                      │ ли fnl в обращении опущен, то счи-  │
│                      │ тается, что fnl=*FRAMES* .          │
├──────────────────────┼─────────────────────────────────────┤
│ (DEDESCR q sb*)      │   Создает новый дескриптор q со     │
│                      │ слотами s1 ... sN.                  │
├──────────────────────┼─────────────────────────────────────┤
│ (DINSTANCE q sb*)    │   Создает экземпляр дескриптора q   │
│                      │ со слотами s1 ... sN.               │
╘══════════════════════╧═════════════════════════════════════╛

.
                            - 32 -



        П1.4. Извлечение информации из сети фреймов.

╒══════════════════════╤═════════════════════════════════════╕
│      Синтаксис       │              Семантика              │
╞══════════════════════╪═════════════════════════════════════╡
│ (FPRINT : fnl)       │   Указанные фреймы выводятся на эк- │
│                      │ ран в виде, удобном для восприятия. │
│                      │ По умолчанию fnl=*FRAMES*           │
│                      │   Результат - список фреймов, кото- │
│                      │ рые удалось отпечатать.             │
├──────────────────────┼─────────────────────────────────────┤
│ (PPRINT : pnl)       │   Указанные процедуры выводятся на  │
│                      │ экран в виде, удобном для восприя-  │
│                      │ тия. По умолчанию pnl=*PROCEDURES*  │
│                      │   Результат - список процедур, ко-  │
│                      │ торые удалось отпечатать.           │
├──────────────────────┼─────────────────────────────────────┤
│ (FGET f : s a k)     │   Результат - список подструктур или│
│                      │ их имен, извлеченных из сети фреймов│
│                      │ на основании приводимых аргументов. │
│                      │   Например:                         │
│                      │   (FGET f) - возвращает список имен │
│                      │ слотов фрейма f.                    │
│                      │   (FGET f s а) - возвращает список  │
│                      │ имен данных из аспекта a слота s    │
│                      │ фрейма f.                           │
│                      │   Подробнее см. в п.2.8.            │
│                      │   По умолчанию a=$VALUE             │
│                      │                k=(L -C ! @ A H 1)   │
│                      │   Присоединенные процедуры выполня- │
│                      │ ются. Комментарии обрабатываются    │
├──────────────────────┼─────────────────────────────────────┤
│ (FGET1 f : s a v l)  │   То же, что и FGET  с той разницей,│
│                      │ что в если результат FGET равен NIL,│
│                      │ то запрос распространяется  на фрей-│
│                      │ мы, имена которых содержатся в каче-│
│                      │ стве  имен  данных  слота AKO до тех│
│                      │ пор, пока один из них не выдаст  ре-│
│                      │ зультат, отличный от NIL.           │
├──────────────────────┼─────────────────────────────────────┤
│ (FGETN f : s a v l)  │   То же, что и FGET1, но результиру-│
│                      │ ющий запрос представляет  конкатена-│
│                      │ цию запросов во все возможные фреймы│
│                      │ вдоль AKO связи.                    │
├──────────────────────┼─────────────────────────────────────┤
│ (FGET- f s a : v l)  │   То же, что и FGET, но не выполня- │
│                      │ ются присоединенные  процедуры и не │
│                      │ обрабатываются комментарии.         │
│                      │   Принцип умолчания на аспект "a" не│
│                      │ распространяется.                   │
├──────────────────────┼─────────────────────────────────────┤
│ (FGET1- f s a : v l) │   То же, что и FGET1, но не выпол-  │
│                      │ няются присоединенные процедуры и   │
│                      │ не обрабатываются комментарии.      │
│                      │   Принцип умолчания на аспект "a" не│
│                      │ распространяется.                   │
├──────────────────────┼─────────────────────────────────────┤
│ (FGETN- f s a : v l) │   То же, что и FGETN, но не выпол-  │
│                      │ няются присоединенные процедуры и   │

                            - 33 -
│                      │ не обрабатываются комментарии.      │
│                      │   Принцип умолчания на аспект "a" не│
│                      │ распространяется.                   │
├──────────────────────┼─────────────────────────────────────┤
│ (FGET-STRUCTURE f :  │   Результат - список подструктур    │
│ s a v l)             │ выделенных из фрейм структуры на    │
│                      │ основании приводимых аргументов.    │
│                      │   Например:                         │
│                      │   (FGET-STRUCTURE f s а) - возвра-  │
│                      │ щает аспект "a" слота "s" фрейма "f"│
│                      │   Алгоритм поиска данных описан в   │
│                      │ п.3.1                               │
│                      │   По умолчанию a=$VALUE             │
│                      │   Присоединенные процедуры выполня- │
│                      │ ются. Комментарии обрабатываются    │
├──────────────────────┼─────────────────────────────────────┤
│ (FGET-STRUCTURE1 f : │   То же, что и FGET-STRUCTURE, но в │
│ s a v l)             │ случае если результат               │
│                      │ FGET-STRUCTURE nil запрос распрост- │
│                      │ раняется на фреймы, имена которых   │
│                      │ содержатся в качестве имен данных   │
│                      │ слота AKO, до тех пор пока один из  │
│                      │ них не выдаст результат отличный от │
│                      │ nil.                                │
├──────────────────────┼─────────────────────────────────────┤
│ (FGET-STRUCTUREN f : │   То же, что и FGET-STRUCTURE1,но   │
│ s a v l)             │ результирующий запрос представляет  │
│                      │ конкатенацию запросов во все воз-   │
│                      │ можные фреймы вдоль AKO связи.      │
├──────────────────────┼─────────────────────────────────────┤
│ (FGET-STRUCTURE- f : │   То же, что и FGET-STRUCTURE,      │
│ s a v l)             │ FGET-STRUCTURE1, FGET-STRUCTUREN,   │
│ (FGET-STRUCTURE1- f  │ но не выполняются присоединенные    │
│ : s a v l)           │ процедуры и не обрабатываются ком-  │
│ (FGET-STRUCTUREN- f  │ ментарии.                           │
│ : s a v l)           │   Принцип умолчания на аспект "a" не│
│                      │ распространяется.                   │
├──────────────────────┼─────────────────────────────────────┤
│ (FGETE f s : a)      │   =(FGET f s a '(E))                │
├──────────────────────┼─────────────────────────────────────┤
│ (FGETV f s : k)      │   =(FGET f s $VALUE k), причем в    │
│                      │ случае неуспеха результат формируют │
│                      │ процедуры, наследуемые из аспекта   │
│                      │ $IF-REQ слота "s" фрейма "f".       │
├──────────────────────┼─────────────────────────────────────┤
│ (FGET-STRUC f : s a  │   =(FGET-STRUCTURE f : s a v l m)   │
│ v l m)               │                                     │
├──────────────────────┼─────────────────────────────────────┤
│ (FGET-SEL f s a : k  │   Извлекает (при помощи FGET с уче- │
│ : l1 m1 ... lN mN)   │ том ключей k) из аспекта a слота s  │
│                      │ фрейма f, все данные, которые со-   │
│                      │ держат комментарии (l1 m1) ... (lN  │
│                      │ mN).                                │
├──────────────────────┼─────────────────────────────────────┤
│ (FGETIND f1 (s+) : a │   Цепной вариант FGET. Возвращает   │
│ k)                   │ (FGET fN sN : a k), где f2=(FGET f1 │
│                      │ s1 : a), f3=(FGET f2 s2 : a) и т.д. │
│                      │ Если f2 или f3 или ... или fN явля- │
│                      │ ются многоэлементными списками, то  │
│                      │ результатом FGET от такого списка   │
│                      │ будет конкатенация результатов      │
│                      │ FGETов от элементов этого списка.   │

                            - 34 -
├──────────────────────┼─────────────────────────────────────┤
│ (FHERITAGE f : s)    │   Возвращает список имен слотов     │
│                      │ фрейма f и всех фреймов, связанных  │
│                      │ с ним через слот s. Если слот s не  │
│                      │ задан, то s=AKO.                    │
├──────────────────────┼─────────────────────────────────────┤
│ (FDESCENDANTS f : s) │   Возвращает список всех имен фрей- │
│                      │ мов (за исключением самого фрейма   │
│                      │ f) дерева отношения s с корнем в f. │
│                      │ Если s не задано, то s=AKO.         │
├──────────────────────┼─────────────────────────────────────┤
│ (FTREE f : s)        │   Возвращает списковое представле-  │
│                      │ ние дерева отношения s с корнем в   │
│                      │ f. Если s не задано, то s=AKO.      │
├──────────────────────┼─────────────────────────────────────┤
│ (FRINGE f : s)       │   Возвращает  список  всех  листьев │
│                      │ дерева  отношения  s  с корнем в f. │
│                      │ Если s не задано, то s=AKO.         │
├──────────────────────┼─────────────────────────────────────┤
│ (FCHILDREN f : s)    │   Возвращает список всех непосредс- │
│                      │ твенных потомков фрейма f в дереве  │
│                      │ отношения s. Если s не задано, то   │
│                      │ s=AKO.                              │
├──────────────────────┼─────────────────────────────────────┤
│ (FINHERIT f s : a)   │   =(FGET f s a (C 0))               │
├──────────────────────┼─────────────────────────────────────┤
│ (FINHERIT1 f s : a)  │   =(FGET f s a (C O))               │
├──────────────────────┼─────────────────────────────────────┤
│ (FINHERIT2 f s : a)  │   =(FGET f s a (C O 2))             │
├──────────────────────┼─────────────────────────────────────┤
│ (FSLOTS f)           │   Результат - список имен слотов    │
│                      │ фрейма f                            │
├──────────────────────┼─────────────────────────────────────┤
│ (FRAMES)             │   Возвращает в качестве результата  │
│                      │ список фреймов, находящихся в опе-  │
│                      │ ративной памяти (активных фреймов). │
├──────────────────────┼─────────────────────────────────────┤
│ (PROCEDURES)         │   Возвращает в качестве результата  │
│                      │ список процедур, находящихся в опе- │
│                      │ ративной памяти (активных фреймов). │
├──────────────────────┼─────────────────────────────────────┤
│ (DESCRS)             │   Список всех дескрипторов.         │
├──────────────────────┼─────────────────────────────────────┤
│ (FQUERY f s a : ref  │   Поиск в сети фреймов (см. описание│
│      field relation) │   в п.2.8).                         │
╘══════════════════════╧═════════════════════════════════════╛

.
                            - 35 -



                  П1.5. Предикаты MFRL/PC.

╒══════════════════════╤═════════════════════════════════════╕
│      Синтаксис       │              Семантика              │
╞══════════════════════╪═════════════════════════════════════╡
│ (FACTIV? f)          │   Результат - T, если фрейм f нахо- │
│                      │ дится в оперативной памяти. Иначе - │
│                      │ nil.                                │
├──────────────────────┼─────────────────────────────────────┤
│ (PACTIV? pn)         │   Результат - T, если процедура pn  │
│                      │ находится в оперативной памяти.     │
│                      │ Иначе - nil                         │
├──────────────────────┼─────────────────────────────────────┤
│ (FRAME? f)           │   Результат - фрейм-структура фрей- │
│                      │ ма f, если этот фрейм находится в   │
│                      │ оперативной памяти или открытом     │
│                      │ разделе ВБО. Иначе - nil            │
├──────────────────────┼─────────────────────────────────────┤
│ (DNAME? q)           │   Имя дескриптора q, если q являет- │
│                      │ ся дескриптором в оперативной памя- │
│                      │ ти или в базе объектов (в этом слу- │
│                      │ чае он загружается в оперативную    │
│                      │ память). (CAR q), если q - список.  │
│                      │ В противном случае NIL.             │
├──────────────────────┼─────────────────────────────────────┤
│ (AKO? f1 fN)         │   Возвращает список имен фреймов    │
│                      │ вида (f1 ... fN), где f2 является   │
│                      │ AKO-прототипом для f1, f3 является  │
│                      │ AKO-прототипом для f2 и т.д. Если   │
│                      │ такой список построить не удается,  │
│                      │ то результат NIL.                   │
├──────────────────────┼─────────────────────────────────────┤
│ (INSTANCE? f1 fN)    │   Аналогично AKO?, но вместо        │
│                      │ AKO-прототипов берутся INSTANCE-эк- │
│                      │ земпляры.                           │
├──────────────────────┼─────────────────────────────────────┤
│ (FLINK? f1 fN : s)   │   Возвращает список имен фреймов    │
│                      │ вида (f1 ... fN), где f1 непосредс- │
│                      │ твенно связан связью s с f2, f2 не- │
│                      │ посредственно связан связью s с f3  │
│                      │ и т.д. По умолчанию s=AKO. Если та- │
│                      │ кой список построить не удается, то │
│                      │ результат NIL.                      │
├──────────────────────┼─────────────────────────────────────┤
│ (ISA? f1 fn : s)     │   То же, что и FLINK?, но связи s   │
│                      │ могут наследоваться.                │
├──────────────────────┼─────────────────────────────────────┤
│ (TOPIC? f1 f2 : s)   │   Если существует такой фрейм fx,   │
│                      │ что (FLINK? f1 fx s) & (FLINK? f2   │
│                      │ fx s), то возвращает (FLINK? f2 fx  │
│                      │ s).                                 │
├──────────────────────┼─────────────────────────────────────┤
│ (FCOMMENT? d l m*)   │   Возвращает данное d, если оно со- │
│                      │ держит комментарий с меткой l и со- │
│                      │ общениями m*.                       │
├──────────────────────┼─────────────────────────────────────┤
│ (FCHECK? f s : d)    │   Возвращает T, если данное d удов- │
│                      │ летворяет условиям, которые насле-  │
│                      │ дуются из фрейма f, слота s, аспек- │

                            - 36 -
│                      │ та $REQUIRE. По умолчанию берется   │
│                      │ данное из фрейма f, слота s, аспек- │
│                      │ та $VALUE.                          │
├──────────────────────┼─────────────────────────────────────┤
│ (FMATCH? f q)        │   Возвращает T, если фрейм f сопос- │
│                      │ тавим с дескриптором q. Формируются │
│                      │ также глобальные переменные         │
│                      │ *MATCHED* и *UNMATCHED* (см. п. )   │
╘══════════════════════╧═════════════════════════════════════╛


.
                            - 37 -



      П1.6. Интерфейс с виртуальной базой объектов (ВБО).

╒══════════════════════╤═════════════════════════════════════╕
│      Синтаксис       │              Семантика              │
╞══════════════════════╪═════════════════════════════════════╡
│ (OPEN-BASE : bn)     │   Загружается ВБО bn  из директории │
│                      │ с именем bn.       Результат        │
│                      │         - имя загруженной ВБО. Если │
│                      │ ВБО  с указанным именем нет в теку- │
│                      │ щей директории,  то она может  быть │
│                      │ создана.                            │
├──────────────────────┼─────────────────────────────────────┤
│ (CLOSE-BASE)         │   Закрывает ВБО.  Результат  -  имя │
│                      │ ВБО, с которой прекращена работа.   │
├──────────────────────┼─────────────────────────────────────┤
│ (FOPEN name)         │   Раздел "name" ВБО объявляется от- │
│                      │ крытым. Раздел, бывший ранее откры- │
│                      │ тым,     объявляется     пассивным. │
│                      │ Результат  - список из "name". Если │
│                      │ раздел открыть не удалось  (ВБО  не │
│                      │ была  предварительно загружена), то │
│                      │ NIL.                                │
│                      │   Если "name" опущено  в обращении, │
│                      │ то  открывается  глобальный  раздел │
│                      │ ВБО с именем GLB. В этом случае ре- │
│                      │ зультат - NIL.                      │
├──────────────────────┼─────────────────────────────────────┤
│ (FCLOSE)             │   Текущий открытый раздел ВБО  зак- │
│                      │ рывается. Активным становится ранее │
│                      │ пассивный раздел.  Результат - спи- │
│                      │ сок, из имени закрытого раздела.    │
├──────────────────────┼─────────────────────────────────────┤
│ (FLOAD{f | fnl | pn  │   Указанные фреймы или процедуры    │
│ | pnl)               │ загружаются в оперативную память из │
│                      │ текущего открытого раздела ВБО.     │
│                      │   Внимание!!! Если объект не найден │
│                      │ в открытом разделе ВБО, производит- │
│                      │ ся  попытка  загрузить  его из гло- │
│                      │ бального раздела ВБО.  Результат  - │
│                      │ имя  загруженного  объекта или NIL, │
│                      │ если объект в ВБО не найден.        │
├──────────────────────┼─────────────────────────────────────┤
│ (FSAVE : fnl)        │   Указанные фреймы помещаются в от- │
│                      │ крытый  раздел ВБО,  после чего они │
│                      │ удаляются  из  оперативной  памяти. │
│                      │ Результат - список имен сохраненных │
│                      │ объектов. Если fnl опущен, то fnl=* │
│                      │ FRAMES*.                            │
├──────────────────────┼─────────────────────────────────────┤
│ (PSAVE : pnl)        │   То же, что и FSAVE, но в случае,  │
│                      │ когда fnl опущен, cчитается, что    │
│                      │ fnl=*PROCEDURES*.                   │
├──────────────────────┼─────────────────────────────────────┤
│ (FPSAVE)             │   = (FSAVE) + (PSAVE)               │
├──────────────────────┼─────────────────────────────────────┤
│ (MAINT kw : name1    │   Сервисная процедура   взаимодейс- │
│ name2 flag)          │ твия с ВБО.  kw задает режим работы │
│                      │ функции MAINT.  kw = DIR  -  печать │
│                      │ оглавления  раздела name1 ВБО, если │

                            - 38 -
│                      │ name1 опущено -  печать  оглавления │
│                      │ всей ВБО. Если kw=DELP - MAINT уда- │
│                      │ ляет раздел name1 из ВБО.  При kw = │
│                      │ DELO  - происходит удаление объекта │
│                      │ name1 из раздела name2. Если flag не│
│                      │ равно NIL, то оглавление не печата- │
│                      │ ется, а выдается в виде результата. │
├──────────────────────┼─────────────────────────────────────┤
│ (OGLAV : name flag)  │   Печать оглавления  раздела  name  │
│                      │ ВБО,  если  name   опущено - печать │
│                      │ оглавления всей ВБО. Если flag не   │
│                      │ равно NIL, то оглавление не печата- │
│                      │ ется, а выдается в виде результата. │
├──────────────────────┼─────────────────────────────────────┤
│ (FDESTROY f)         │   Указанный фрейм затирается в опе- │
│                      │ ративной памяти и удаляется из ВБО. │
│                      │ Результат - имя удаленного фрейма   │
├──────────────────────┼─────────────────────────────────────┤
│ (PDESTROY pn)        │   Указанная процедура удаляется из  │
│                      │ системы. Результат имя процедуры.   │
│                      │ Процедура удаляется также из ВБО.   │
├──────────────────────┼─────────────────────────────────────┤
│ (BASE_GC)            │   Процедура уплотнения информации в │
│                      │ открытом разделе ВБО.               │
│                      │   В процессе своей  работы печатает │
│                      │ об'ем  ВБО  в байтах до и после уп- │
│                      │ лотнения. Эта процедура запускается │
│                      │ автоматически каждый раз при превы- │
│                      │ шении ограничителя  на  размер  ВБО,│
│                      │ устанавливаемый функцией BD_SIZE    │
├──────────────────────┼─────────────────────────────────────┤
│ (BD_SIZE : n)        │   Устанавливает максимальный размер │
│                      │ в байтах раздела  ВБО.  Как  только │
│                      │ размер  раздела  ВБО превысит уста- │
│                      │ новленный предел -  происходит  его │
│                      │ уплотнение. (т.е. из него удаляют-  │
│                      │ ся все дубликаты функций и фреймов) │
│                      │   Если n опущено - в качестве ре-   │
│                      │ зультата возвращается значение те-  │
│                      │ кущего предела                      │
╘══════════════════════╧═════════════════════════════════════╛

.
                            - 39 -


                  П1.7. Активация процедур

╒══════════════════════╤═════════════════════════════════════╕
│      Синтаксис       │              Семантика              │
╞══════════════════════╪═════════════════════════════════════╡
│ (FAPPLY d)           │   Вычисляет значение  данного  d  с │
│                      │ учетом   комментариев   с   метками │
│                      │ STATUS:,  PARM: и PARMQ:. Возвраща- │
│                      │ ется полученное значение, заключен- │
│                      │ ное в скобки.                       │
├──────────────────────┼─────────────────────────────────────┤
│ (FPROG (d*) (m*))    │   Последовательно вычисляет    (при │
│                      │ помощи  FAPPLY)  данные  из (d*) до │
│                      │ тех пор,  пока не будет получен ре- │
│                      │ зультат, отличный от NIL, который и │
│                      │ будет результатом FPROG.  Если спи- │
│                      │ сок  (m*)  не пуст,  то вычисляются │
│                      │ только те данные,  которые содержат │
│                      │ в комментарии с меткой TYPE:  сооб- │
│                      │ щения из (m*).                      │
├──────────────────────┼─────────────────────────────────────┤
│ (FPROGL (d*))        │   Вычисляет (при помощи FAPPLY)     │
│                      │ данные из (d*), учитывая при этом   │
│                      │ функторы OR, NOT, ALT, IF, THEN,    │
│                      │ ELSE, FI (см. п. ).                 │
├──────────────────────┼─────────────────────────────────────┤
│ (FEXEC f s a (m*))   │   =(FPROG (FGET f s a) (m*))        │
├──────────────────────┼─────────────────────────────────────┤
│ (FNEED f s (m*))     │   =(FEXEC f s $IF-NEEDED (m*))      │
├──────────────────────┼─────────────────────────────────────┤
│ (FEVAL d : f s a v)  │   =(FAPPLY d), причем создается     │
│                      │ среда, в которой: :FRAME = f, :SLOT │
│                      │ = s, :FACET = a, :VALUE = v.        │
├──────────────────────┼─────────────────────────────────────┤
│ (FCHECK f s : v*)    │   Возвращает список из результатов  │
│                      │ проверок для каждого значения v из  │
│                      │ (v*). Каждый результат проверки     │
│                      │ имеет вид: (<итог> <TRUE-список>    │
│                      │ <FALSE-список> <?-список>) где      │
│                      │ <итог> = T, если v удовлетворяет    │
│                      │ всем условиям из (FGET f s $REQUIRE │
│                      │ (C)); <итог> = NIL, если имеются    │
│                      │ неудовлетворенные условия; <итог> = │
│                      │ ?, если имеются неопределенные ус-  │
│                      │ ловия. <TRUE-список> - это список   │
│                      │ всех удовлетворившихся условий и    │
│                      │ т.д. По умолчанию (v*) = (FGET f s  │
│                      │ $VALUE (-H)).                       │
├──────────────────────┼─────────────────────────────────────┤
│ (FCHECK-SUMMARY f s  │   То же, что и FCHECK, но возвраща- │
│ v*)                  │ ет список итогов.                   │
├──────────────────────┼─────────────────────────────────────┤
│ (FCHECK-INST f)      │   Выполняет для всех значений всех  │
│                      │ слотов фрейма f соответствующие     │
│                      │ присоединенные процедуры, наследуе- │
│                      │ мые из аспекта $IF-ADDED.           │
├──────────────────────┼─────────────────────────────────────┤
│ (FGNEED f s : a k    │   Совпадает с результатом (FGET f s │
│ (m*))                │ a k), если это не NIL. В противном  │
│                      │ случае совпадает с результатом      │

                            - 40 -
│                      │ (FNEED f s : (m*)).                 │
├──────────────────────┼─────────────────────────────────────┤
│ (FGNEEDR f s : a k   │   То же, что и FGNEED, но если сра- │
│ (m*))                │ батывает FNEED, то ее результат за- │
│                      │ носится в аспект a слота s фрейма   │
│                      │ f.                                  │
├──────────────────────┼─────────────────────────────────────┤
│ (FTRACE f list)      │   Подключить к работе FRL-процессо- │
│                      │ ра процедуры трассировки. f - имя   │
│                      │ фрейма, содержащего трассирующие    │
│                      │ процедуры, а list - список вида     │
│                      │ ((<мета-имя-подструктуры> <условие> │
│                      │ ... ). <Мета-имя-подструктуры> -    │
│                      │ это есть FRAME, SLOT, VALUE, LABEL  │
│                      │ или MESSAGE. <Условие> представляет │
│                      │ один из следующих атомов: IF-ADDED, │
│                      │ IF-REMOVED, IF-GETED, что интерпре- │
│                      │ тируется следующим образом:         │
│                      │   IF-ADDED - трассирующие процедуры │
│                      │ запускаются при добавлении в систе- │
│                      │ му структуры с соответствующим ме-  │
│                      │ та-именем; IF-REMOVED - трассирую-  │
│                      │ щие процедуры запускаются при уда-  │
│                      │ лении из системы структуры с соот-  │
│                      │ ветствующим мета-именем; IF-GETED - │
│                      │ трассирующие процедуры запускаются  │
│                      │ при извлечении из сети структуры с  │
│                      │ соответствующим мета-именем.        │
│                      │   Если list опущен, то подключаются │
│                      │ все возможные трассирующие процеду- │
│                      │ ры фрейма f.                        │
├──────────────────────┼─────────────────────────────────────┤
│ (FUNTRACE)           │   Отключает все трассирующие проце- │
│                      │ дуры.                               │
╘══════════════════════╧═════════════════════════════════════╛

.
                            - 41 -



     П1.8. Вспомогательные функции.

╒══════════════════════╤═════════════════════════════════════╕
│      Синтаксис       │              Семантика              │
╞══════════════════════╪═════════════════════════════════════╡
│ (SWITCH-AKO : s)     │   Наследование направляется вдоль   │
│                      │ слота s. По умолчанию s = AKO.      │
├──────────────────────┼─────────────────────────────────────┤
│ (SWITCH-INSTANCE :   │   Устанавливает имя связи, ревер-   │
│ s)                   │ сивной по отношению к AKO. По умол- │
│                      │ чанию s = INSTANCE.                 │
├──────────────────────┼─────────────────────────────────────┤
│ (FREF d : k)         │   Определяет референта для данного  │
│                      │ d в соответствии с ключами k.       │
├──────────────────────┼─────────────────────────────────────┤
│ (FINDIRECT d : k)    │   Определяет референта для косвен-  │
│                      │ ного данного d.                     │
├──────────────────────┼─────────────────────────────────────┤
│ (FINDCOMMENT (d*) l  │   Возвращает NIL, если ни одно дан- │
│ m)                   │ ное из (d*) не имеет комментария с  │
│                      │ меткой l и сообщением m.            │
├──────────────────────┼─────────────────────────────────────┤
│ (FADD-COMMENT d c)   │   Встраивает комментарий c в данное │
│                      │ d.                                  │
├──────────────────────┼─────────────────────────────────────┤
│ (REMDUP (n*))        │   Возвращает (n*) без повторений.   │
├──────────────────────┼─────────────────────────────────────┤
│ (FMINUS list1 list2) │   Результат - список list1 из кото- │
│                      │ рого удалены все элементы, входящие │
│                      │ в list2                             │
├──────────────────────┼─────────────────────────────────────┤
│ (ADJOIN obj list)    │   Аналогично CONS с той разницей,   │
│                      │ что ADJ не добавляет в список list  │
│                      │ повторяющиеся элементы              │
├──────────────────────┼─────────────────────────────────────┤
│ (ADD_TO_FULL list1   │   Аналогично APPEND с той разницей, │
│              list2)  │ что результирующий список создается │
│                      │ без повторяющихся элементов         │
├──────────────────────┼─────────────────────────────────────┤
│ (FGENAME : name)     │   Результат - уникальное системное  │
│                      │ имя, имеющее в качестве префикса    │
│                      │ значение name. По умолчанию         │
│                      │ name=SYS.                           │
├──────────────────────┼─────────────────────────────────────┤
│ (FGETNAME : name)    │   Результат - последнее сгенериро-  │
│                      │ ванное уникальное системное имя,    │
│                      │ имеющее в качестве префикса значе-  │
│                      │ ние name. По умолчанию name=SYS.    │
├──────────────────────┼─────────────────────────────────────┤
│ (EVLIST list)        │   Результат - список, состоящий из  │
│                      │ результатов вычисления всех соот-   │
│                      │ ветствующих элементов list          │
╘══════════════════════╧═════════════════════════════════════╛

