;Основная функция
(defun main ()
(rds 'L:\\inavs.txt)
(wrs 'L:\\outavs.txt)
(loop
    ((equal expr '(eof)) nil)
    (setq res '())
    (setq expr (read))
    ((equal expr '(eof)) nil)
    (get_var expr)
    (setq res (by_order res))

    (setq val (make-list (length res) 0))
    (setq end_val (make-list (length res) 1))
    (print (append (list 'F '=) expr))
    (princ res) (spaces 1) (print F)

    (setq flag (valid expr))

    (loop
        ((eq flag nil) (print 'invalid_input) (terpri))
        (princ val) (spaces 1)
        (print (calc (inst_var expr res val)))
        (setq val (reverse (set_val (reverse val) 0)))
        ((equal val end_val) (princ val) (spaces 1) (print (calc (inst_var expr res val))) (terpri))
    )
)
(rds)
(wrs)
'ok
)
;Подстановка значений в выражение
(defun inst_var (expr res val)
    (cond
        ((null (cdr res)) (subst (pop val) (pop res) expr))
        (T (inst_var (subst (pop val) (pop res) expr) res val))
    )
)
;Переход к новому набору переменных
(defun set_val (lst p)
    (cond
        ((null lst) nil)
        ((eq (car lst) 0)
            (if (eq p 0)
                (progn (append (list 1) (cdr lst)))
                (progn (append (list 1) (set_val (cdr lst) 0)))
            )
        )
        ((eq (car lst) 1)
            (if (eq p 0)
                (progn (append (list 0) (set_val (cdr lst) 0)))
                (progn (append (list 1) (set_val (cdr lst) 1)))
            )
        )
        (T (break))
    )
)
;Вычисление функций МЛ
(defun calc (lexpr)
    (cond
        ((null lexpr) nil)
        ((atom lexpr) lexpr)
        ((eq (car lexpr) !) (otr (calc (cadr lexpr))))
        ((eq (cadr lexpr) &) (kon (calc (car lexpr)) (calc (caddr lexpr))))
        ((eq (cadr lexpr) \|) (diz (calc (car lexpr)) (calc (caddr lexpr))))
        ((eq (cadr lexpr) >) (imp (calc (car lexpr)) (calc (caddr lexpr))))
        ((eq (cadr lexpr) /) (sheff (calc (car lexpr)) (calc (caddr lexpr))))
        ((eq (cadr lexpr) +) (mod2 (calc (car lexpr)) (calc (caddr lexpr))))
        ((eq (cadr lexpr) =) (ekv (calc (car lexpr)) (calc (caddr lexpr))))
    )
)
;Функции МЛ
(defun kon (l r)
    (if (eq l 0) 
        (if (eq r 0) 0 0)
        (if (eq r 0) 0 1)
    )
)
(defun diz (l r)
    (if (eq l 0) 
        (if (eq r 0) 0 1)
        (if (eq r 0) 1 1)
    )
)
(defun imp (l r)
    (if (eq l 0) 
        (if (eq r 0) 1 1)
        (if (eq r 0) 0 1)
    )
)
(defun otr (l)
    (if (eq l 0) 1 0)
)
(defun sheff (l r)
    (if (eq l 0) 
        (if (eq r 0) 1 1)
        (if (eq r 0) 1 0)
    )
)
(defun mod2 (l r)
    (if (eq l 0) 
        (if (eq r 0) 0 1)
        (if (eq r 0) 1 0)
    )
)
(defun ekv (l r)
    (if (eq l 0) 
        (if (eq r 0) 1 0)
        (if (eq r 0) 0 1)
    )
)
;Множество переменных
(defun get_var (expr)
    (cond
        ((atom expr)
            (if (member expr res)
                nil
                (push expr res)
            )
        )
        ((eq (car expr) !) (get_var (cadr expr)))
        (T (get_var (car expr)) (get_var (caddr expr)))
    )
)
;Упорядочивание набора переменных
(defun by_order (expr)
    (setq res '())
    (setq resf '())
    (setq asc (copy-list expr))
    (loop
        (push (ascii (pop asc)) res)
        ((null asc) nil)
    )
    (loop
        (push (ascii (eval `(min ,@res))) resf)
        (setq res (remove (eval `(min ,@res)) res))
        ((null res) nil)
    )
    (reverse resf)
)
;Проверка ввода
(defun valid (expr)
    (cond
        ((null expr) T)
        ((atom expr) T)
        ((and (eq (car expr) !) (= 2 (length expr))) (and T (valid (cadr expr))))
        ((and (member (cadr expr) '(& \| > / + =)) (= 3 (length expr))) (and T (valid (car expr)) (valid (caddr expr))))
        (T nil)
    )
)

